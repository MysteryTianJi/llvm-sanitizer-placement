\chapter*{摘\quad 要}
\addcontentsline{toc}{chapter}{摘要}

随着现代软件系统规模与复杂性的呈指数级增长，内存安全问题已成为制约软件可靠性与安全性的核心瓶颈。以 C/C++ 为代表的系统级编程语言因缺乏内建的内存边界检查与自动化生命周期管理机制，极易遭受缓冲区溢出（Buffer Overflow）、释放后使用（Use-After-Free）及空指针解引用等内存破坏漏洞的攻击。这些漏洞不仅增加了软件维护的成本，更常被攻击者利用作为入侵系统的主要切入点，严重威胁关键信息基础设施的安全。

为了应对这一挑战，基于编译器的动态程序分析技术——Sanitizer（如 AddressSanitizer、UndefinedBehaviorSanitizer 等）被广泛应用于软件开发与测试流程中。该类技术通过在编译时插入影子内存（Shadow Memory）映射与红区（Redzone）检测代码，实现了对运行时内存错误的精准捕获。然而，Sanitizer 的引入往往伴随着显著的资源消耗，其运行时性能开销通常高达 2--3 倍，并导致二进制体积显著膨胀，这极大地限制了其在生产环境及资源受限场景下的部署。更为严峻的是，最新的研究表明，编译器优化 Pass（如死代码消除、指令组合等）可能会在无意中破坏 Sanitizer 的插桩逻辑，引发 ``Sanitizer-Eliding'' 现象，导致本应被检出的漏洞在优化后的版本中被忽略，从而产生安全隐患。

针对上述问题，本研究立足于 LLVM 编译器基础设施，深入探讨了 Sanitizer 插桩位置对漏洞检测能力与程序运行效率的双重影响。本论文首先系统剖析了 LLVM Pass Pipeline 的处理流程与优化依赖关系，识别了关键的优化阶段（Pre-Optimization, Mid-Optimization, Post-Optimization 以及 Link-Time Optimization）。在此基础上，本研究设计并实现了一个可配置的插桩框架，能够灵活调整 Sanitizer Pass 在编译管道中的执行时机。通过构建包含 SPEC CPU 基准测试集与 Juliet 漏洞测试套件的大规模实验环境，本研究量化评估了不同插桩策略在运行时开销、代码体积增长及漏洞检出率方面的表现。

初步研究结果旨在揭示编译器优化与安全插桩之间的相互作用机理，并试图寻找在“高安全性保障”与“低性能损耗”之间的最优平衡点。本研究提出的分级插桩策略模型，有望为现代编译器安全机制的设计提供理论支撑，并为工业界在不同应用场景下选择最佳构建配置提供具有实践价值的指导建议。

\vspace{1cm}

\noindent \textbf{关键词：} LLVM；Sanitizer；编译优化；插桩策略；内存安全；动态分析